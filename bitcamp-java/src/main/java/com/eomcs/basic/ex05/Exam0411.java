// 비트 이동 연산자 : >>, >>>, << 
package com.eomcs.basic.ex05;

//비트이동 연산자 : 비트 이용의 유효범위

public class Exam0411 {
  public static void main(String[] args) {

    System.out.println(3 << 1);
    //    00000000 00000000 00000000 00000011 = 3
    //  0|0000000 00000000 00000000 000000110 = 6

    System.out.println(3<<33); // 6
    System.out.println(3<<34); // 12
    System.out.println(3<<65); // 6
    System.out.println(3<<97); // 6
    // 같은 값이 나오는 이유?
    // int 타입의 값에 대해 비트 이동을 할 때는 0~31까지만 유효, 
    // 만일 넘는 경우 32로 나눈 나머지 값을 비트 이동으로 간주한다
    // long 타입의 값에 대해 비트 이동을 할 때는 0~63까지만 유효, 
    // 만일 넘는 경우 64로 나눈 나머지 값을 비트 이동으로 간주한다


    // int 값에 대해 비트 이동은 0 ~ 31 이다
    // long 값에 대해 비트 이동은 0 ~ 63 이다
    // 비트 이동 유효 범위를 벗어난다면?
    // int 데이터인 경우 비트 이동 값은 하위 5비트 만 유효하다
    // long 데이터인 경우 비트 이동 값은 하위 6비트 만 유효하다
    // 예)
    // n << s
    // - n이 int 타입이라면, s & 0b11111 = 비트 이동,  s % 32 결과와 같음
    // - n이 long 타입이라면, s & 0b111111 = 비트 이동 ,  s % 64 결과와 같음
    // 예1)
    // 3 << 33
    // n = 00000000 00000000 00000000 00000011 = 3
    // s = 00000000 00000000 00000000 00100001 = 33
    // 비트 이동  = > s & 0b11111
    //   00000000 00000000 00000000 00100001 = 33
    //   00000000 00000000 00000000 00100010 = 34
    // & 00000000 00000000 00000000 00011111 
    // --------------------------------------
    //   00000000 00000000 00000000 00000001 = 1 (33)
    //   00000000 00000000 00000000 00000010 = 2 (34)

    // 3 << 33 = 3 << 1
    // 3 << 34 = 3 << 2
    
    // 3 << 65 = 3 << 1
  }
}
