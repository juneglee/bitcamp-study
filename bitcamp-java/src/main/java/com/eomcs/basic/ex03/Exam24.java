package com.eomcs.basic.ex03;

//정수를 메모리에 저장하는 방법

public class Exam24 {
  //리터럴 : 4바이트(기본,32비트), 8바이트 (L or l, 64비트)
  public static void main(String[] args) {

    System.out.println(23); 
    // 0000 0000 0000 0000 0000 0000 0001 0111
    System.out.println(-23);
    
    // 1) sign-magnitude : 맨 앞비트로 음수 표시
    // - 1000 0000 0000 0000 0000 0000 0001 0111(-23)
    // - 음수의 젤 앞에 1으로 표현
    // - 23 + (-23) = 0의 결과값이 제대로 나오지 않는다 
    // 2) 1's complement (1의 보수 방식)
    // - 모든 비트를 1이 되는 수로 바꾼다. 0을 1로 1을 0으로 바꾼다
    // - 1111 1111 1111 1111 1111 1111 1110 1000 (-23)
    // - 23 + (-23) 한후 맨 뒤에 1을 추가로 더한다
    // - 1 0000 0000 0000 0000 0000 0000 0000 0000 (32비트 를 넘어가는 1은 버리기 때문에 0이 된다)
    // - 음수를 더 할때는 항상 결과에 1을 추가해야 한다.
    // 3) 2's complement (2의 보수 방식)
    // - 1의 보수로 저장된 음수 값을 더 할 때 마다 계산 결과에 1을 추가하는 번거로움을 없애기 위해 음수를 정장할 때 미리 1을 추가해 두는 방법
    // - 1111 1111 1111 1111 1111 1111 1110 1000 (-23) + 1 => 1111 1111 1111 1111 1111 1111 1110 1001 (-23)
    // - 음수를 메모리에 저장할때는 2의 보수방식으로 사용
    }
}