# 배열 - 배열을 선언하는 방법 
배열?
 - 같은 종류의 메모리를 쉽게 만드는 방법

 - 문법
        메모리종류[] 메모리이름 = new 메모리종류[개수]
        데이터타입[] 변수명 = new 데이터타입[개수];
        ex) int[] arr = new int[5];

 - C언어 스타일 
        데이터타입 변수명[] = new 데이터타입[개수];
        ex) int arr[] = new int[5];

# 배열 - 배열 메모리에 방법 
배열 메모리에 접근
  - 문법
          배열변수[인덱스] = 값;
          ex) arr1[0] = 100;

 - 배열의 인덱스는 0부터 시작한다.
 - 인덱스의 범위는 0 ~ (배열개수 - 1) 이다.

# 배열 - 배열 레퍼런스와 배열 인스턴스
 배열 선언문 분석:

     arr1
       - 배열 메모리의 주소를 담는 변수이다.
      - 이렇게 메모리의 주소를 보관하는 변수를 '레퍼런스'라 부른다.
    
     new int[5]
       - new 명령은 사용할 메모리를 확보하는 명령이다.
       - 즉 연속된 5 개의 int 타입 메모리를 준비하라는 명령이다.
       - 사용할 메모리를 확보한 후 그 메모리의 찾아 갈 수 있도록 시작 주소를 리턴한다.
       - 이렇게 값을 저장하기 위해 확보된 메모리를 "인스턴스"라 부른다.
    
     new 명령은 메모리를 확보하는 명령이다.
     - 리턴 값은 확보된 메모리의 시작 주소이다.

 [정리]
 레퍼런스(reference)란?
 - 값이 아닌 메모리의 주소를 담는 변수.

 인스턴스(instance)란?
 - 값을 저장하는 메모리.

    - 배열 레퍼런스만 따로 선언할 수 있다.
    int[] arr1;
    
     주의!
     - 아직 레퍼런스는 배열의 메모리를 알지 못하기 때문에 사용할 수 없다.
    arr1[0] = 100; // 컴파일 오류!
    
     배열 인스턴스를 생성하고 그 주소를 레퍼런스에 저장한다.
    arr1 = new int[5];
    
     이제 레퍼런스는 배열 메모리를 알기 때문에 레퍼런스를 통해 배열 인스턴스에 값을 담을 수 있다.
    arr1[0] = 100;
    
     배열 인스턴스에 저장된 값을 출력해보자!
    System.out.println(arr1[0]);

    int[] arr1;
    arr1 = new int[5];
    
    int[] arr2 = arr1; // 언제든 배열 인스턴스의 주소를 다른 레퍼런스에 담을 수 있다.
    
    arr2[0] = 100;  //arr2와 arr1은 같은 배열 인스턴스를 가리킨다.
    
    System.out.println(arr1[0]); // arr2를 통해 값을 저장한 후, arr1을 통해 값을 꺼낼 수 있다.

# 배열 메모리의 기본 값
    일반 변수와 달리 new 명령으로 확보된 메모리는 종류에 상관없이 기본 값으로 자동 초기화 된다.
    따라서 배열 메모리 또한 생성되는 순간 기본 값으로 자동 초기화 된다.
    - 정수 배열(byte[], short[], int[], long[]) : 0
    - 부동소수점 배열(float[], double[]) : 0.0
    - 논리 배열(boolean[]) : false 
    - 문자 배열(char[]) : '\u0000'
    - 주소 변수(Object[]) : null

# 배열 - 배열 메모리 초기화 유형
1)  배열 메모리를 특정 값으로 초기화 
    arr1[0] = 100;
    arr1[1] = 90;
    arr1[2] = 80;
    arr1[3] = 70;
    arr1[4] = 60;

2) 배열 선언 + 초기화 명령

    2-1) 데이터타입[] 변수명 = new 데이터타입[]{값, 값, 값};
          int arr2[] = new int[]{100, 90, 80, 70, 60}; 

	    //int arr2[] = new int[5]{100, 90, 80, 70, 60}; // 문법오류! 배열 개수 지정하면 안된다. 
  
 	   int arr3[] = {0, 0, 0, 0, 0}; // new int[] 생략 가능
   
    2-2) 데이터타입[] 변수명;
         변수명 = new 데이터타입[]{값, 값, 값};
         int[] arr1;
         arr1 = new int[]{10, 20, 30}; 
     
	    int[] arr4;
	    //arr4 = {100, 90, 80, 70, 60}; // 컴파일 오류!

    배열 초기화 명령을 따로 실행할 때는 new int[] 를 생략할 수 없다.
    int[] arr5;
    arr5 = new int[]{0, 0, 0, 0, 0}; 


# 배열 - 배열 인스턴스와 가비지

    int[] arr1;
    arr1 = new int[5];
    arr1[0] = 100;
    
    레퍼런스에 다른 배열 인스턴스의 주소를 담을 수 있다.
    arr1 = new int[] {200, 200, 200};
     주의!
     - arr1이 보관하고 있던 주소는 잃어버렸기 때문에 이전 배열 인스턴스는 사용할 수 없다.
     - 이렇게 주소를 잃어버려 사용할 수 없는 인스턴스(메모리)를 '가비지(garbage)'라 부른다.
    
    
 배열 레퍼런스와 인스턴스를 따로 선언하기
    int[] arr1 = null; 
    //null 주소가 없는 것을 의미한다. 0과 같다. 0의 의미는 메모리르르 가리키지 않는다

    // arr1[0] =  100; // runtime error!

    arr1 = new int[5];
    arr1[0] = 100;
    arr1[1] = 100;
    
    //배열 사용 
    System.out.println(arr1[0]);
    System.out.println(arr1[1]);

    int[] arr2;
    arr2 = arr1;

    // 배열 레퍼런스는 배열 인스턴스의 주소를 담는다

    System.out.println(arr1[0]);
    arr2[0]=300;
    System.out.println(arr1[0]);

    // 배열 인스턴의 각 항목은 생성되는 순간 기본 값으로 자동 초기화 된다
    // byte, short, int, long q배열 ; 0
    // float. double ; 0.0
    // boolean : false 
    // char : '\u0000'
    // Object : null

    System.out.println(arr1[2]);

    int[] arr3 = new int[3];
    arr3[0]=30;
    System.out.println(arr3[0]);

    arr2 = arr3; // arr3 -> arr2, 더이상 arr2에는 1과 연동되지 않고 3과 연동되어 3에 저장한다 
    
    System.out.println(arr2[0]); 
    
    arr1 = arr2; // arr2 -> arr1,

    System.out.println(arr1[0]); 
    
    그럼 arr1에 저장되었던 기존 배열 인스턴스에는 어떻게 접근하는가
     => 어떻게 접근하는가?
     => 처음 생성했던 배열 인스턴스의 주소를 갖고 있는 레퍼런스가 없기 때문에 접근 할 수 없다.
     => 이렇게 주소를 잃어버려 접근 할 수 없는 메모리를 "가지비 (garbage)"라고 부른다
     => 가비지 JVM 실행 중에 메모리가 부족 할때 가비지 수집기에 의해 메모리에서 해제 된다
        물론 JVM을 종료하면 당연히JVM이 사용하던 모든 메모리는 OS에 반남되기 대문에 가비지 또한 반납될 것이다
     => 전산학에서는 "가비지"를 dangling object 라고 부른다

     가비지 동작
     1) 메모리가 부족할때 
     2) CPU가 한가할 때