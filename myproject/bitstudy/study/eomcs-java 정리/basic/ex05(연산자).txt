연산자 
1. 산술 연산자 +, -, *, /, %
	- 연산자의 우선순위 

	- 연산자의 기본단위
~ 주의 사항 
    byte x = 5, y = 6, z;
    z = x; // OK!
    z = y; // OK!
    //z = x + y; // 컴파일 오류!
    
    short s1 = 5;
    short s2 = 6;
    short s3;
    s3 = s1; // OK!
    s3 = s2; // OK!
    //s3 = s1 + s2; // 컴파일 오류!

- byte와 short로 정수 변수를 선언할때는 그때의 입력값에서 주의를 해야 한다 
- 결국. 숫자의 크기와 상관없이 작은 숫자를 다루더라도 정수를 다룰 때는 그냥 int를 사용하라!

	- 연산의 결과 타입
    int i = 5;
    int j = 2;
    float r = i / j; // 결과
    r = (float)i / (float)j; <- 형변환
    // float / float = float
    // i / j의 값은 2.5가 되고
    // r에 저장되는 것은 2.5이다.
   
형변환 시 주의 사항
    byte b;
    b = (byte)256; 
    System.out.println(b); // 0
    // int(4 byte)  => 0000 0000 0000 0000 0000 0001 0000 0000
    // byte(1 byte) => ---- ---- ---- ---- ---- ---- 0000 0000

2. 관계 연산자 <, <=, >, >=, ==, !=  
	- 비교 및 부동소수점
	- 부동소수점의 비교 
관계 연산자에서 부동소수점에서의 주의 사항
    double d1 = 987.6543;
    double d2 = 1.111111;
    System.out.println((d1 + d2) == 988.765411);   // 결과는 false이다.
    					     // 987.6543 + 1.111111 = 988.7654110000001
     이유?
     - 부동소수점 값을 연산할 때 IEEE 754 명세에 따라 작업을 수행한다. 그 과정에 값의 왜곡이 발생할 수 있다.
     - CPU나 OS, JVM의 문제가 아니다.
     - IEEE 754 명세에 따라 부동소수점을 처리하는 모든 컴퓨터에서 발생하는 문제이다.
     => 그래서 부동 소수점의 비교를 대충 다루지 말라!

3. 논리 연산자 &&(and), ||(or), !(not), ^(XOR; exclusive-OR)
	- &, |와 && || 의 차이점	
// &&, ||
// - 앞의 피연산자의 값으로 결과를 알 수 있다면 뒤의 명령은 실행하지 않는다.
// 
// &, |
// - 앞의 피연산자로 결과를 알 수 있을 지라도,  뒤에 놓은 명령까지 모두 실행한다.
    boolean a = false;
    boolean b = false;
    boolean r = a & (b = true); // r = false  - 앞의 피연산자로 결과를 알 수 있을 지라도,  뒤에 놓은 명령까지 모두 실행한다.
    boolean r = a && (b = true);  // r = false  - 앞의 피연산자의 값으로 결과를 알 수 있다면 뒤의 명령은 실행하지 않는다.

    boolean a = true;
    boolean b = false;
    boolean r = a || (b = true); // r = true -  왼쪽 값으로 이미 결과를 알 수 있기 때문에 오른쪽 문장은 실행하지 않는다.
    boolean r = a | (b = true); // r = true -  왼쪽 값으로 결과를 확정할 수 있더라도 무조건 오른쪽 문장을 실행한다.

	- 추가 ★ 도형을 이용하여 값을 구하는 방법
	- 연산자의 활용을 통해 반도체를 설명하라 

4.  비트 연산자(&, |, ^, ~)

- 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
- 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
- 왼쪽 빈자리를 음수 양수 상관없이 무조건 0으로 채운다.
 - 오른쪽 경계를 넘어간 비트는 자른다.

    System.out.println(a & b);
    // a = 0000 0000 0000 0000 0000 0000 0110 1100
    // b = 0000 0000 0000 0000 0000 0000 0101 0101
    // ----------------------------------------------------------
    //     0000 0000 0000 0000 0000 0000 0100 0100 = 68

    System.out.println(a | b);
    // a = 0000 0000 0000 0000 0000 0000 0110 1100
    // b = 0000 0000 0000 0000 0000 0000 0101 0101
    // ----------------------------------------------------------
    //     0000 0000 0000 0000 0000 0000 0111 1101 = 125

    System.out.println(a ^ b);
    // a = 0000 0000 0000 0000 0000 0000 0110 1100
    // b = 0000 0000 0000 0000 0000 0000 0101 0101
    // ----------------------------------------------------------
    //     0000 0000 0000 0000 0000 0000 0011 1001 = 57

    // 비트 연산에서 not은 ! 연산자가 아니라 ~ 연산자 이다.
    System.out.println(~a);
    // a = 0000 0000 0000 0000 0000 0000 0110 1100
    // ----------------------------------------------------------
    //     1111 1111 1111 1111 1111 1111 1001 0011 = -109

주의 
     &&, ||, ! 의 피연산자(operand)는 반드시 boolean 이어야 한다.
     그리고 계산 결과는 boolean이다.
    boolean r;
    //r = 10 && 20; // 컴파일 오류!
    //r = 10 || 20; // 컴파일 오류!

     &, |, ^, ~(not) 의 피연산자는 정수이어야 한다.
     그리고 계산 결과도 정수이다.
    
    //r = 10 & 20; // 컴파일 오류! 비트 연산의 결과는 정수이다. 
    
    int r2 = 10 & 20; // OK!
    
    //float r3 = 10.2f & 20.3f; // 컴파일 오류!

5. 비트 연산자 >>, >>>, << 
    int i = 1;
    //     00000000 00000000 00000000 00000001 = 1  
    
    System.out.println(i << 1);
    //   0|00000000 00000000 00000000 0000001x 
    //     00000000 00000000 00000000 00000010 = 2
    
    System.out.println(i << 2);
    //  00|00000000 00000000 00000000 000001xx 
    //     00000000 00000000 00000000 00000100 = 4
    
    System.out.println(i << 3);
    // 000|00000000 00000000 00000000 00001xxx 
    //     00000000 00000000 00000000 00001000 = 8    
    
    System.out.println(i << 4);
    //0000|00000000 00000000 00000000 0001xxxx 
    //     00000000 00000000 00000000 00010000 = 16  
int i = 0b01101001; // 105
    
    System.out.println(i); 
    // 00000000000000000000000001101001 


    System.out.println(i >> 1); 
    // x0000000000000000000000000110100|1
    // 00000000000000000000000000110100   => 52
    
    System.out.println(i >> 2); 
    // xx000000000000000000000000011010|01
    // 00000000000000000000000000011010   => 26
    
    System.out.println(i >> 3); 
    // xxx00000000000000000000000001101|001
    // 00000000000000000000000000001101   => 13
    
    System.out.println(i >> 4);
    // xxxx0000000000000000000000000110|1001
    // 00000000000000000000000000000110   => 6

// 음수일 경우,
    //
    i = 0b11111111_11111111_11111111_10101001; // -87
    
    System.out.println(i); 
    
    System.out.println(i >> 1); 
    // x1111111111111111111111111010100|1   
    // 11111111111111111111111111010100    => -44

    System.out.println(i >> 2); 
    // xx111111111111111111111111101010|01   
    // 11111111111111111111111111101010    => -22

    System.out.println(i >> 3); 
    // xxx11111111111111111111111110101|001   
    // 11111111111111111111111111110101    => -11

    System.out.println(i >> 4);
    // xxxx1111111111111111111111111010|1001   
    // 11111111111111111111111111111010    => -6

--------------------------------------------------------------------------------------------------------------------------
 응용 문제는 따로 예제를 만든다
	- 응용 1
       int i = 0x27a130ff;
        int a, b, c, d;
	- 응용 2
        boolean c, cpp, java, js, python, php, html, css;
	- 응용 3
	- 응용을 설명하면서 실무에 자주 사용된다고 말한다 
--------------------------------------------------------------------------------------------------------------------------
6. 조건 연산자
	- 조건 연산자의 기본 사용 방법 (조건 ? 표현식1 : 표현식2)

         조건연산자
         => 조건 ? 표현식1 : 표현식2
         => 조건이 참이면 표현식1을 실행하고,
             조건이 거짓이면 표현식2를 실행한다.

        /*
        (age > 18) ? System.out.println("성인이다.") : 
                     System.out.println("미성년자이다.");  //컴파일 오류!

        */
        // 표현식 자리에는 문자가 되었든 숫자가 되었든 
        // 실행 결과가 놓여져야 한다.
        // 위의 System.out.println(...) 문장은 결과를 리턴하지 않는다.
        // 그래서 컴파일 오류이다.

        int age = 20;
        String message = (age > 18) ? "성년" : "미성년";
        System.out.printf("나이 %d는(은) %s이다.\n", age, message);


        // 표현식 자리에는 문자가 되었든 숫자가 되었든 
        // 실행 결과가 놓여져야 한다.
        // 위의 System.out.println(...) 문장은 결과를 리턴하지 않는다.
        // 그래서 컴파일 오류이다.

// 표현식(expression)?
// - 작업을 수행한 후 결과를 리턴하는 명령이다.
//
// 문장(statement)?
// - 작업을 수행시키는 명령어이다.
//
// 문장과 표현식의 관계
// - statement 중에서 결과를 리턴하는 statement를 expression이라 부른다.


7. 증감 연산자 => ? :
	- 후위(post-fix) 증가 (응용1, 응용2)
int i = 2;
i++;
i++;		
      System.out.println(i);
      System.out.println(i++); // System.out.println(4); 
      System.out.println(i);

      int j = 8;
      j = j++; // 결과값 8
        
      // int temp = i;
      // i = i + 1;
      // i = temp;

        int i = 2;
        int result = i++ + i++ * i++; 

        // 
        // int result = 2 + 3 * 4;
        // int result = 2 + 12;
        // int result = 14;

	- 전위(pre-fix) 증가 (응용1, 응용2)
        System.out.println(i); // 4
        System.out.println(++i); // System.out.println(5)
        System.out.println(i); // 5
       
        int i = 2;
        i = ++i; //3 

        int i = 2;
        int result = ++i + ++i * ++i;
        // 1) int result = 3 + 4 * 5;
        // 2) int result = 3 + 20;
        // 3) int result = 23;

	- 증감 연사자의 오류에 대해 설명 

주의
        // 주의!
        // 1) pre-fix 연산자나 post-fix 연산자를 리터럴에 적용할 수 없다.
        //int x = ++100; // 컴파일 오류!
        //x = 100++; // 컴파일 오류!

        // 2) 변수에 동시에 적용할 수 없다.
        int y = 100;
        //++y++; // 컴파일 오류!
        //(++y)++; // 컴파일 오류!, 값을 ++할 수 없기 때문에 
        //++(y++); // 컴파일 오류!

8. 할당 연산자 +=  -=  *=  /=  %=  &=  |=  ^=  <<=  >>=  >>>=
	- 할당 연산자의 기본 사용 
        //i = i + 20;
        i += 20; // += 연산자를 사용하면 위의 코드를 축약할 수 있다.
