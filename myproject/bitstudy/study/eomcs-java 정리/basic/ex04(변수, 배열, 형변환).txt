변수 

0. assignment (계산기, 가위바위보)
- scanner, import, nextLine, nextInt
- 계산기 ( equals, if ~ else if ~ else)
- 가위바위보 (math ramdom, &&, ||, if ~ else if, print, return)

1.변수 선언
- 데이터 타입 변수1, 변수2, 변수3;
- 변수에 값 할당 (할당연산자)
- 변수 선언과 값 할당 동시에
- 변수 선언 및 초기화
- 변수의 값 변경

2. 블록 안에서 변수 선언 위치
- 미리, 중간
- 변수 선언 오류
- 변수 사용 - (다른도구; 메서드 (함수)에 값을 전달)
- 변수의 종류 (자바 원시 타입 변수, 래퍼런스 변수)
- 변수의 메모리 크기
- 정수 변수 - 변수와 리터럴의 크기
              - 크기가 다른 변수끼리 값 할당
              - 
- 부동소수점의 변수 - 변수의 메모리 크기
- 문자 변수 ( UCS-2 코드 확인하기)

3. 배열(exam 5)

- 배열을 선언
배열 - 같은 종류의 메모리를 쉽게 만드는 방법 
 - 문법
        메모리종류[] 메모리이름 = new 메모리종류[개수]
        데이터타입[] 변수명 = new 데이터타입[개수];
        ex) int[] arr = new int[5];

 - C언어 스타일 
        데이터타입 변수명[] = new 데이터타입[개수];
        ex) int arr[] = new int[5];
# 배열 - 배열 메모리에 방법 
 배열 메모리에 접근
 - 문법
          배열변수[인덱스] = 값;
          ex) arr1[0] = 100;

 - 배열의 인덱스는 0부터 시작한다.
 - 인덱스의 범위는 0 ~ (배열개수 - 1) 이다.

  유효하지 않은 인덱스를 지정
  - 실행 중에 오류가 발생한다.  
  - 컴파일 할 때는 인덱스가 유효한지 알 수 없다.
    int[] arr1 = new int[5];
    //arr1[5] = 600; // 실행 오류(Runtime Error), 이때 인덱스가 0~4로 5개의 배열로 구성되어 있으므로, [5]은 인덱스에서 벗어난 것이다 
    //arr1[-1] = 700; // 실행 오류(Runtime Error)

- 배열 레퍼런스와 배열 인스턴스
// 배열 선언문 분석:
    // arr1
    //   - 배열 메모리의 주소를 담는 변수이다.
    //   - 이렇게 메모리의 주소를 보관하는 변수를 '레퍼런스'라 부른다.
    //
    // new int[5]
    //   - new 명령은 사용할 메모리를 확보하는 명령이다.
    //   - 즉 연속된 5 개의 int 타입 메모리를 준비하라는 명령이다.
    //   - 사용할 메모리를 확보한 후 그 메모리의 찾아 갈 수 있도록 시작 주소를 리턴한다.
    //   - 이렇게 값을 저장하기 위해 확보된 메모리를 "인스턴스"라 부른다.
    //
    // new 명령은 메모리를 확보하는 명령이다.
    // - 리턴 값은 확보된 메모리의 시작 주소이다.

// 레퍼런스(reference)란?
// - 값이 아닌 메모리의 주소를 담는 변수.
//
// 인스턴스(instance)란?
// - 값을 저장하는 메모리.

// 배열 레퍼런스만 따로 선언할 수 있다.
    int[] arr1;
    
    // 주의!
    // - 아직 레퍼런스는 배열의 메모리를 알지 못하기 때문에 사용할 수 없다.
    //arr1[0] = 100; // 컴파일 오류!
    
    // 배열 인스턴스를 생성하고 그 주소를 레퍼런스에 저장한다.
    arr1 = new int[5];
    
    // 이제 레퍼런스는 배열 메모리를 알기 때문에 레퍼런스를 통해 배열 인스턴스에 값을 담을 수 있다.
    arr1[0] = 100;

- 배열 메모리의 기본 값
// 일반 변수와 달리 new 명령으로 확보된 메모리는 종류에 상관없이 기본 값으로 자동 초기화 된다.
    // 따라서 배열 메모리 또한 생성되는 순간 기본 값으로 자동 초기화 된다.
    // - 정수 배열(byte[], short[], int[], long[]) : 0
    // - 부동소수점 배열(float[], double[]) : 0.0
    // - 논리 배열(boolean[]) : false 
    // - 문자 배열(char[]) : '\u0000'
    // - 주소 변수(Object[]) : null


- 배열 메모리 초기화

// 정리!
// 1) 배열 선언 + 초기화
//    데이터타입[] 변수명 = new 데이터타입[]{값, 값, 값};
//    - 배열 메모리를 초기화시킬 때는 배열 개수를 지정해서는 안된다.
//    - 배열을 초기화시키는 값의 개수 만큼 메모리가 만들어진다.
//    - 즉 다음은 값 개수만큼 int 메모리가 3개가 생성된다.
//      ex) int[] arr = new int[]{10, 20, 30};
//    - 다음과 같이 new 명령을 생략할 수 있다.
//      데이터타입[] 변수명 = {값, 값, 값};
//      ex) int[] arr = {10, 20, 30};
// 
// 2) 배열 선언 후 따로 배열 초기화 문장 실행
//    데이터타입[] 변수명;
//    변수명 = new 데이터타입[]{값, 값, 값};
//    ex) 
//    int[] arr1;
//    arr1 = new int[]{10, 20, 30}; 
//    - 변수를 선언한 후 따로 배열을 초기화시킬 때는 
//      new 명령을 생략할 수 없다.

- 가비지 (그림을 통한 가비지의 표현)

    int[] arr1;
    arr1 = new int[5];
    arr1[0] = 100;
    
    // 레퍼런스에 다른 배열 인스턴스의 주소를 담을 수 있다.
    arr1 = new int[] {200, 200, 200};
    // 주의!
    // - arr1이 보관하고 있던 주소는 잃어버렸기 때문에 이전 배열 인스턴스는 사용할 수 없다.
    // - 이렇게 주소를 잃어버려 사용할 수 없는 인스턴스(메모리)를 '가비지(garbage)'라 부른다.
    //
    
    // 새 배열 인스턴스의 값 출력하기

4. 상수 - 변수의 값을 고정하는 방법
    // 변수
    // => 언제든지 값을 변경할 수 있다.
    int a;
    a = 10;
    a = 100;
    a = -300;

 // 상수
    // => 값을 오직 한 번만 저장할 수 있다.
    // => 변수 앞에 final을 붙여라!
    final int b;
    b = 100;


    // 변수와 상수를 구분하기 위해서
    // => 상수인 경우 이름을 보통 모두 대문자로 작성한다.
    // => 그리고 변수를 선언하는 문자에서 바로 값을 초기화시킨다.
    final float PI = 3.14159f;
    final float MILE = 0.621371f;

5. 변수의 종류(exam 7 ~ 8)
- 변수의 종류 - 종류에 따른 변수의 사용 범위★
- 변수의 종류 - 같은 블록에서는 중복 선언 불가

6. 형변환 (exam 9)
- 정수 변수 ==> 부동소수점 변수
- 부동소수점 변수 ==> 정수 변수
- 명시적 형변환
- 명시적 형변환 : 큰 정수 변수의 값을 작은 정수 변수에 저장
- 명시적 형변환이 불가능한 경우 






