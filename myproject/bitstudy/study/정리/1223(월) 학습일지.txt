- Test 1 (배열의 값중 최대값을 출력)

- Test 2 (	배열에 들어있는 값을 오름차순으로 정렬) 
  - 옆자리를 비교하여 큰순서를 오늘쪽으로 보내고. 다음을 반복한다
- Test 3 (배열의 순서를 reverse)
  - 반으로 나누어서 반복을 한다
  - for문에서 변수를 두개 선언하여 값을 비교할 수 있도록 한다
  - 절반을 반복한 후에 전체를 선언한 값을 한번더 실행  

- JVM 실행 순서와 메모리
  - method, heap, stack
- JVM이 메모리를 다루는 방법

재귀호출 ex 0450
- 호출(sum(value-1)을 알아야 리턴을한다)을 다 끝내고 리턴을 받는다 
- 끝나는 조건이 있어야 한다 (if문으로 표현)

- 디버깅을 통해 JVM의 과정을 확인

class
1.  사용자 정의 데이터 타입 
= 메모리 구조를 설계
class Member { }
 => Member m = new Member()

2. method 분류
= 서로 관련된 일을 하고 메서드를 유지보수하기 쉽게 분류
class Boardhandler {
void listboard {}
void addboard {}
}


1. [Method Area] class loding 
2. [Method Area] main 호출
3. [JVM stack] main에 사용할 로컬(local) 변수 준비
4. [JVM stack] main에 로컬 변수 a와 b에 값을 저장 (frame 메모리)
5. [Method Area] swap을 호출
6. [JVM stack] swap에 사용할 로컬(local) 변수 준비
7. [JVM stack] argument를 parameter에 저장

8 [Method Area] 실행
9. [Heap] swap a와 b 출력 (출력 후 stack의 메모리 삭제)
10. [Heap] main a와 b 출력 (출력 후 stack의 메모리 삭제)

-> 출력 후 제거된 메모리와 모든 메모리는 OS에 반납

method area => code
stack => memory

exam420
-> int arr[] = new int[] {} 의 값처럼 new를 사용하여 배열의 인스턴스를 생성할때는 
    Heap의 메모리를 사용한다. 이때 int arr[]는 주소의 값으로 stack에 저장되며, new int[]의 
값과는 다르다 

exam 510 
-> 사용자 정의 데이터 타입을 통해 class를 정의하여, 두개의 class를 만들때는 Method Area의 두개의 공간이 만들어진다
 이때는 클래스안의 클래스로 '중첩 클래스' 클래스라고 불리며, nested class= inner class라고 한다