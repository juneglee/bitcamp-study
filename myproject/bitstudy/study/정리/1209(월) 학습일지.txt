1. 10진수, 8진수, 16진수, 2진수 표현방식
8진수 : 앞에 0을 반드시 붙임
16진수 : 0x 반드시 붙임 (대문자 사용 가능, 앞에 0 가능)
2진수 0b 반드시 붙임 (대문자 사용 가능, 앞에 0 가능)
실무에서는 소문자를 사용한다

2. 메모리 저장 방식 (4바이트, 8바이트)
    // 금액 표기를 위해 _ 사용 (한국 4자리, 미국 3자리 )
    // 맨앞,뒷자리는 안된다
중간에 사용 불가능 (단 8진수에서는 가능)

3. 메모리 크기와 유효 값이 범위
//리터럴 : 4바이트(기본,32비트), 8바이트 (L or l, 64비트)
System.out.println(100); //jvm에서 4바이트 메모리에 저장
System.out.println(100L); //jvm에서 8바이트 메모리에 저장 (같은 100이지만 8바이트 메모리에 저장되는 것을 기억)

System.out.println(Integer.MAX_VALUE); //4바이트 최대 정수값 출력 (integer : 정수)
System.out.println(Integer.MIN_VALUE); //4바이트 최소 정수값 
System.out.println(Long.MAX_VALUE); // 8바이트 최대 정수값
System.out.println(Long.MIN_VALUE); // 8바이트 최소 정수값

4. 2^n ~~ 2^n-1 ~ 2^(n-1 )-1

5. 음수 표현 방식 (sign magnitude, 1의 보수 방식, 2의 보수 방식)
 // 1) sign-magnitude : 맨 앞비트로 음수 표시
    // - 1000 0000 0000 0000 0000 0000 0001 0111(-23)
    // - 음수의 젤 앞에 1으로 표현
    // - 23 + (-23) = 0의 결과값이 제대로 나오지 않는다 

    // 2) 1's complement (1의 보수 방식)
    // - 모든 비트를 1이 되는 수로 바꾼다. 0을 1로 1을 0으로 바꾼다
    // - 1111 1111 1111 1111 1111 1111 1110 1000 (-23)
    // - 23 + (-23) 한후 맨 뒤에 1을 추가로 더한다
    // - 1 0000 0000 0000 0000 0000 0000 0000 0000 (32비트 를 넘어가는 1은 버리기 때문에 0이 된다)
    // - 음수를 더 할때는 항상 결과에 1을 추가해야 한다.

    // 3) 2's complement (2의 보수 방식)
    // - 1의 보수로 저장된 음수 값을 더 할 때 마다 계산 결과에 1을 추가하는 번거로움을 없애기 위해 음수를 정장할 때 미리 1을 추가해 두는 방법
    // - 1111 1111 1111 1111 1111 1111 1110 1000 (-23) + 1 => 1111 1111 1111 1111 1111 1111 1110 1001 (-23)
    // - 음수를 메모리에 저장할때는 2의 보수방식으로 사용

//- 2의 보수를 만드는 방법 2:
//  - 오른쪽에서부터 1을 찾는다.
//  - 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.
//    예) 0010 1001(41) => 1101 0111(-41)
//                ^                ^
//    예) 0010 1100(44) => 1101 0100(-44)
//              ^                ^

1) sign-magnitude 방식
    0000 0000 0001 0111(23)
+  1000 0000 0001 0111(-23)
---------------------------------
    1000 0000 0010 1110 (23+(-23)= 0 x)

2) 1의 보수
    0000 0000 0001 0111(23)
+  1111 1111 1110 1000(-23)
---------------------------------
    1111 1111 1111 1111 
+  0000 0000 0000 0001 
---------------------------------
  1 0000 0000 0000 0000 (4바이트(32비트)를 넘어가면 버리기 때문에 1은 무시한다)

3) 2의 보수
    0000 0000 0001 0111(23)
+  1111 1111 1110 1001(-23)
---------------------------------
  1 0000 0000 0000 0000  (4바이트(32비트)를 넘어가면 버리기 때문에 1은 무시한다)

6. 바이어스 방식

7. 부동소수점 최대, 최소 값의 범위 출력
System.out.println(Float.MAX_VALUE); 
System.out.println(Float.MIN_VALUE);
System.out.println(Double.MAX_VALUE);
System.out.println(Double.MIN_VALUE);

8. 부동소수점의 표현 방법
       // 4바이트는 소수점에 위치와 상관없이 7자리의 갯수가 중요함 
        // 이때 7자리의 갯수를 "유효자릿수"라고 한다
        
        // 주의 : 7자리라도 구겨질수 있음 (내부의 규칙에 따라 JVM 에 보정해줌) 
            //-- 100% 정확하게 꺼내지 못하는 이유는?
            //-- 부동소수점이 2진수로 변환할때 IEEE 754 규칙에 의해 변경되지 못하는 경우가 았음

★ 9. 부동소수점 > 저장 > 정규화 > 

★ 10. character set : 문자에 대해 코드 값을 정의

 




