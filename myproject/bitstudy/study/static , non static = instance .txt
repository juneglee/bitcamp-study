
스태틱 메서드 
 1) 클래스 메서드 
   => static 붙은 메서드이다.
   => 클래스 이름으로 호출할 수 있다.
   => "스태틱 메서드"라고도 부른다.

1>
public class Car {
  static String name;
  static int type;
  static String colar;
  static int speed;
  static int energy;
  static int power;
  static int cleanLevel;
}

2> 
public class Test03 {
  public static void main(String[] args) {
    Car.name = "봉봉";
    Car.type = 1;
    Car.colar ="빨강";
    Car.peed = 0;
    Car.energy = 100;
    Car.power = 200;

3>
  static void speedUp() { 
    if (Car.speed >= 100) 
      return;
    Car.speed += 10;
  }
- 이처럼 한개의 정보만을 다루기 때문에 두 개 이상의 정보를 다루고 싶으면 인스턴스 값으로 만든다
  static은 class 당 한개의 정보만을 저장할 수 있으며 여러개의 정보를 저장할 수 없다.
  여러개를 저장하고 싶으면 static을 제거해야 한다. 즉, 인스턴스로 만들어야 한다
  인스턴스는 static을 제거하고. new라는 명렁어로 지정해야 한다. 이때 new는 heap 저장된다.
- 스태틱 메서드를 만들때는 Method Area에 생성되고 저장된다 (Heap에 저장되지 않는다 )
  값을 여러개 분리 x , 한개의 변수만 생성가능하다

★ - 특정 인스턴스(instance)에 대해 사용하는 경우에만 인스턴스를 사용해야 한다. 
     만약 특정 인스턴스에 작용하는게 아니라면 스태틱(static)으로 만든다

 실무
 => 일단 인스턴스 메서드로 무조건 만들라!
 => 인스턴스 변수를 완전히 사용하지 않음을 확신하면 그 때 클래스 메서드로 전환하라!


-------------------------------------------------------------------------------------------------------------------------------------------

인스턴스 메서드

1>
public class Car {
  String name;
  int type;
  String colar;
  int speed;
  int energy;
  int power;
  int cleanLevel;
}
- 스태틱을 제거 함으로써 여러개의 인스턴스 값으로 사용 할 수 있도록 만든다 

2>
  public static void main(String[] args) {
    Car c1 = new Car(); //식판에 주소를 담는다
    Car c2 = new Car();
- 여러개를 사용해야 하기 때문에 인스턴스의 주소를 담을 공간을 스택에 만든다 

    c1.name = "봉봉";
    c1.type = 1;
    c1.colar ="빨강";
    c1.speed = 0;
    c1.energy = 100;
    c1.power = 200;

    c2.name = "호호";
    c2.type = 2;
    c2.colar ="검정";
    c2.speed = 0;
    c2.energy = 100;
    c2.power = 300;
- 인스턴스를 만들어 주어 값을 저장한다 

3> 메서드 = 연산자를 클래스로 만들어서 메서드로 불러서 사용한다 
- //연산자의 메서드인 경우는 인스턴스로 많이 사용한다 
  void speedUp() {     
    if (this.speed >= 100) 
      return;
    this.speed += 10;
//this = 메서드를 호출할 때 넘겨준 인스턴스 주소;

4> 값을 비교하여 사용할 수 있도록 만들어 줄 수도 있다 
-- // 하나는 파라미터로 하는 히든 변수(this)로 받아서 비교한다 (this는 생략이 가능하다(추후에 배울 예정))

  int comparePower(Car c) { 
    if (this.power > c.power)	
      return - 1;
    else if (this.power == c.power)
      return 0;
    else
      return 1; //(this.power < c.power)
  }
System.out.printf("c1 vs c2 의 힘 : %d\n", c1.comparePower(c2));
==>  c1.comparePower(c2) =  this.comparePower(c)
==> c1의 power : 200
==> c2의 power : 300

this.power > c.power
this의 값은 : 200
 c의 값은 : 300
 c1 vs c2 의 힘 : 1

ex) this.메서드명();



 주의 사항 
- 인스턴스를 적용에서 비교를 할때, 하나는 파라미터로 적용하고 하나는 this로 적용한다 

-------------------------------------------------------------------------------------------------------------------------------------------

// 내장 변수 this

    static class A {
        int value;
        
        void m4(int value) {
            // 로컬 변수의 이름이 인스턴스 이름과 같을 경우 
            // this를 붙이지 않으면 로컬 변수를 가리킨다.
            value = 200; // 로컬 변수이다.
            
            this.value = 300; // 인스턴스 변수이다.
            // 따라서 로컬 변수가 아닌 인스턴스 변수를 가리키고 싶으면 this를 붙여야 한다

    public static void main(String[] args) {
        // 클래스 메서드는 인스턴스 주소 없이 클래스 이름으로 호출한다.
        // 그래서 클래스 메서드는 this라는 내장 변수가 없는 것이다..
	A.m1();

        // 인스턴스 메서드는 인스턴스 주소가 있어야만 호출할 수 있기 때문에
        // 인스턴스 메서드에는 인스턴스 주소를 받을 수 있는 내장 변수 this가 있다.
          A obj1 = new A();

        // 물론 클래스 메서드도 레퍼런스를 가지고 호출할 수 있지만,
        // 인스턴스 주소가 메서드에 전달되지 않는다.
        // 그래서 클래스 메서드는 내장 변수 this가 없다.

-------------------------------------------------------------------------------------------------------------------------------------------
  생성자?
 => 인스턴스(객체)를 생성한 후에 사용하기 전에 (제대로 쓰일 수 있도록)  유효한(적당한) 값으로 초기화시키 작업을 수행한다.

#  생성자 Overveiw
 class Monitor {
      int bright;
      Monitor (){     //생성자
        bright = 70; //기본을 유지할 수 있도록 유효한 값으로 초기화
                        //없으면 생성자를 기본적으로 만든다
      }
    }
    
    Monitor obj = new Monitor(); //() 안에 int를 입력하면 int(정수)를 써야 한다 //    (); 생성자를 호출
    obj.필드값 = 값 ;

# 생성자를 호출하는 방법
    => 인스턴스를 생성하는 new 명령에서 호출할 생성자의 파라미터 값을 지정하면 된다.
    => 다음과 같이 파라미터 값을 주지 않으면 기본 생성자를 호출하라는 뜻이 된다.

Score s1 = new Score(); 

Score s2 = new Score; // 컴파일 오류!

Score s4 = new Score(true);// 단 논리값을 출력하는 값이 없다 boolean x

# 생성자의 접근을 제한하는 방법
  생성자의 접근 범위를 private으로 설정하면 외부에서 접근할 수 없기 때문에
  결국은 생성자를 호출하지 못하는 상태로 만들 수 있다.
  // 결국 인스턴스를 생성하지 못하게 만든다 

  private X()

# 변수 초기화 - 자동 초기화
- 클래스 변수는 생성되는 순간 0으로 자동 초기화 된다.
    // 정수 byte, short, int ,long, char : 0
    // 부동소수점 float, double : 0.0
    // 논리 : flase

- 인스턴스 변수는 생성되는 순간 0으로 자동 초기화 된다. 

    // 로컬 변수는 자동 초기화되지 않는다.
    // 반드시 사용전에 값을 저장해야 한다.

# 변수 초기화 - 초기화 문장과 생성자의 실행 순서
  static class A {
    int a = 200;

    // 생성자는 초기화 문장을 실행한 후에 호출된다.
    A() {
      this.a = 300;
    }
  }